// Written by Jackson Murphy for CS 4480. February 2016.
package proxyServer;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.Socket;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Iterator;

import javax.xml.bind.DatatypeConverter;

/***
 * Accepts a GET request from a client, checks the request for errors, then
 * forwards the request on to the origin server. Checks the origin server's
 * response for malware against the CYMRU malware registry. If safe, passes back
 * the origin server's response as-is. If nasty, tells the client that they
 * tried to request malware.
 * 
 * Note: Ignores the Accept-Encoding header line from a client.
 */
public class MultiThreadServer implements Runnable {

	// member variables
	Socket clientSocket;

	MultiThreadServer(Socket clientSocket) {
		this.clientSocket = clientSocket;
	}

	/***
	 * Checks the client's request for errors, and then sends it to the origin.
	 * Returns the origin's response as-is to the client.
	 */
	@Override
	public void run() {

		try {
			// Declare variables
			String clientHeaders = ""; // The header lines sent by the client
			boolean isRelativeURL;
			String relativeUrlPath; // The relative version of the url sent by
									// the client

			// Set up ability to read client's message
			BufferedReader inFromClient = new BufferedReader(
					new InputStreamReader(clientSocket.getInputStream()));

			// Parse the request line of the client's HTTP request
			String requestLineStr = inFromClient.readLine();
			String[] requestLine = requestLineStr.split("[ ]+");

			if (requestLine.length != 3) {
				send400Error(clientSocket);
				return;
			}

			// Check for valid request method
			String method = requestLine[0];

			if (!method.equals("GET")) {
				if (method.equals("PUT") || method.equals("POST")
						|| method.equals("HEAD") || method.equals("DELETE"))
					send501Error(clientSocket);
				else
					send400Error(clientSocket);

				return;
			}

			// See if url is relative or absolute. If absolute, extract hostname
			// and check if a port number is specified
			String url = requestLine[1];
			String host = "";
			int originPort = -1;

			if (url.charAt(0) == '/') {
				isRelativeURL = true;
				relativeUrlPath = url;
			}

			else {
				isRelativeURL = false;

				// remove the "http://" from the url, if it exists
				int slashIndex = url.indexOf("//");
				if (slashIndex != -1) {
					host = url.substring(slashIndex + 2);
				} else
					host = url;

				// remove the path from the url and store it
				slashIndex = host.indexOf('/');

				if (slashIndex == -1) {
					send400Error(clientSocket);
					return;
				}

				relativeUrlPath = host.substring(slashIndex);
				host = host.substring(0, slashIndex);

				// look for a specified port number (e.g. google.com:80)
				int colonIndex = host.indexOf(':');
				if (colonIndex != -1) {
					try {
						originPort = Integer.parseInt(host
								.substring(colonIndex + 1));
						host = host.substring(0, colonIndex);
					} catch (NumberFormatException e) {
						originPort = -1;
					}
				}
			}

			// Check that HTTP version is correct
			if (!requestLine[2].equals("HTTP/1.0")
					&& !requestLine[2].equals("HTTP/1.1")) {
				send400Error(clientSocket);
				return;
			}

			// Check that request header lines have the format
			// "<HEADER>: <VALUE>",
			// and append them together for delivery to origin server. Also look
			// for the
			// "Host:" header and omit the "Connection:" header.

			// allows pass-by-ref to get host header from relative url, and port
			// number
			StringBuilder hostStrBldr = new StringBuilder();
			StringBuilder portStrBldr = new StringBuilder();
			try {
				clientHeaders = getHeaderLines(clientSocket, inFromClient,
						hostStrBldr, portStrBldr, isRelativeURL);
			} catch (Exception e) {
				return; // just return, because getHeaderLines() sends error
						// response for us
			}

			if (hostStrBldr.length() != 0)
				host = new String(hostStrBldr); // if request url was relative,
												// the host info was added to
												// StrBldr

			if (portStrBldr.length() != 0) {
				try {
					originPort = Integer.parseInt(portStrBldr.toString());
				} catch (Exception e) { // if couldn't parse string to int, let
										// the program fail when we connect to
										// origin
				}
			}

			/***** End of client request processing *****/

			/***** Create new socket for connection with origin ******/

			// if the port wasn't specified in url, use 80
			if (originPort == -1)
				originPort = 80;

			Socket originSocket = null;
			try {
				originSocket = new Socket(host, originPort);
			} catch (Exception e) {
				send400Error(clientSocket);
				return;
			}

			// Set up ability to send request to the origin server
			DataOutputStream outToOrigin = new DataOutputStream(
					originSocket.getOutputStream());

			// Send client's message to the origin server
			String clientMsg = "GET " + relativeUrlPath + " HTTP/1.0\r\n"
					+ "Host: " + host + "\r\n" + "Connection: close\r\n"
					+ clientHeaders + "\r\n";

			outToOrigin.writeBytes(clientMsg);
			outToOrigin.flush();

			// Get origin server's response.

			// response var will contain the full response, including header
			// lines
			byte[] response;

			// responseLineRef will contain the first response line
			StringBuilder responseLineRef = new StringBuilder();

			// responseBody will contain the body of the response
			ArrayList<Byte> responseBody = new ArrayList<Byte>();

			response = getOriginResponse(originSocket, responseLineRef,
					responseBody);
			originSocket.close();

			// If the response code is 200, proceed to malware check
			String responseLine = responseLineRef.toString();
			if (responseLine.indexOf("200") != -1) {

				// Check if response from origin contains malware.
				// String responseBody = trimHttpHeader(response);
				boolean containsMalware = false; // initialize
				try {
					containsMalware = isMalware(responseBody);
				} catch (IOException e) {
					sendCymruErrorMsg(clientSocket); // problem connecting to
														// malware registry
				}

				/*
				 * send appropriate response to client depending on the presence
				 * of malware. If origin server's response contained malware,
				 * send the client an HTML page indicating this, en lieu of the
				 * nasty malware. If origin server's response did not contain
				 * recognizable malware, send along the response as-is
				 */
				if (containsMalware) {
					response = createMalwareWarningResponse().getBytes();
				}
			}

			// Send response back to client
			DataOutputStream outToClient = new DataOutputStream(
					clientSocket.getOutputStream());
			try {
				outToClient.write(response);
				outToClient.flush();
			} catch (Exception e) {
				System.out
						.println("There was an error sending the results to the client server.");
			}

			// end connection with the client
			clientSocket.close();

		} catch (IOException e) {
			System.out.println("There was an IO Exception");
		}
	} // end of run()

	/**
	 * Check that request header lines have the format "<HEADER>: <VALUE>", and
	 * append them together for delivery to origin server Also look for the
	 * "Host:" header and omit the "Connection:" header.
	 * 
	 * If request gave a relative URL but no Host header, sends a 400 Error
	 * response back to the client
	 * 
	 * @throws Exception
	 */
	static String getHeaderLines(Socket clientSocket,
			BufferedReader inFromClient, StringBuilder host,
			StringBuilder port, boolean isRelativeURL) throws Exception {
		String clientHeaders = "";
		boolean hasHostHeader = false;

		// Continue waiting for lines from client until we receive a "\r\n"
		boolean haveReceivedLastLine = false;

		while (inFromClient.ready() || !haveReceivedLastLine) {

			// Split line using whitespace delimiter
			String headerLine = inFromClient.readLine();

			if (headerLine.equals(""))
				break;

			String[] headerLineArr = headerLine.split("[ ]+");

			int colonIndex = headerLine.indexOf(':');

			if (colonIndex == -1 || headerLineArr.length < 2) {
				send400Error(clientSocket);
				throw new Exception("No ':' in header line");
			}

			if (headerLineArr[0].equals("Host:")) {
				hasHostHeader = true;
				// look for port number
				String hostname = headerLineArr[1];
				if (hostname.indexOf(':') == -1)
					host.append(headerLineArr[1]);
				else { // a port was specified
					port.append(hostname.substring(hostname.indexOf(':') + 1,
							hostname.length()));
					host.append(hostname.substring(0, hostname.indexOf(':')));

				}

				continue; // don't append to clientHeaders; we'll do it
							// manually later
			}

			// Regardless of what the client sends us, we'll be using a
			// "Connection: close" header line with the origin server
			if (headerLineArr[0].equals("Connection:")) {
				continue;
			}

			// Skip the Accept-Encoding header line because this causes
			// problems
			// when sending the client the encoded text from the origin
			// server
			if (headerLineArr[0].equals("Accept-Encoding:")) {
				continue;
			}

			// All header lines must terminate with carriage return and new
			// line
			clientHeaders += headerLine + "\r\n";

		} // end of while loop

		// If client sent us a relative url but no host header, we can't
		// complete their request
		if (isRelativeURL && !hasHostHeader) {
			send400Error(clientSocket);
			throw new Exception(
					"Request was relative URL but provided no 'Host' header");
		}
		return clientHeaders;
	}

	/**
	 * Returns the origin server's full response as an array of bytes (including
	 * header lines). The StringBuilder parameters are used to get the response
	 * header in a pass-by-reference style. The response body Closes the
	 * connection with the origin server upon completion.
	 * 
	 * @throws IOException
	 * 
	 */
	static byte[] getOriginResponse(Socket socket, StringBuilder responseLine,
			ArrayList<Byte> responseBodyRef) throws IOException {

		BufferedInputStream is = new BufferedInputStream(
				socket.getInputStream());
		ByteArrayOutputStream buffer = new ByteArrayOutputStream();
		int countRead; // how many bytes have been read into the array
		byte[] data = new byte[16384]; // initialize to arbitrary size
		while ((countRead = is.read(data, 0, data.length)) != -1) {
			buffer.write(data, 0, countRead);
		}
		buffer.flush();

		byte[] fullResponse = buffer.toByteArray(); // contains the origin's
													// entire response

		// Get the response line from the byte array
		String responseLineStr = "";
		for (byte b : fullResponse) {
			responseLineStr += (char) b;
			if ((char) b == '\n')
				break;
		}
		responseLine.append(responseLineStr);

		// The body of the response is passed out of this method in a
		// pass-by-ref style using the byte[] parameter
		String headerLines = "";
		int startIndex = 0; // index of byte[] at which the response body begins
		for (byte b : fullResponse) {
			headerLines += (char) b;
			startIndex++;
			try {
				if (headerLines.substring(headerLines.length() - 4,
						headerLines.length()).equals("\r\n\r\n")) {
					break;
				}
			} catch (Exception e) { // exceptions are thrown when headerLines is
									// smaller than length 4
			}

		}

		// we now have the index for the beginning of the response body
		// copy the body over the the parameter byte array
		for (int i = startIndex; i < fullResponse.length; i++) {
			responseBodyRef.add(fullResponse[i]);
		}

		return fullResponse;
	}

	/**
	 * Removes the header lines from an Http message, returning only the message
	 * body
	 */
	static String trimHttpHeader(String msg) {
		int blankLineIndex = msg.indexOf("\r\n\r\n", 1);
		try {
			return msg.substring(blankLineIndex + 4);
		} catch (Exception e) { // in case of out of bounds exception
			return msg;
		}
	}

	/**
	 * Converts an ArrayList<Byte> to byte[]
	 */
	static byte[] convertBytes(ArrayList<Byte> list) {
		byte[] ret = new byte[list.size()];
		Iterator<Byte> it = list.iterator();
		for (int i = 0; i < ret.length; i++)
			ret[i] = it.next().byteValue();

		return ret;
	}

	/**
	 * Checks the provided string's MD5 checksum against CYMRU's malware hash
	 * registry. Returns true if CYMRU has identified this string as malware.
	 * Returns false otherwise. NOTE: CYMRU's registry does not contain all
	 * malware in existence, so false negatives are a possibility.
	 * 
	 * @throws IOException
	 */
	static boolean isMalware(ArrayList<Byte> file) throws IOException {
		// get MD5 checksum hash
		// first need to convert ArrayList to byte array
		byte[] bytes = convertBytes(file);

		String md5Hash = getMD5(bytes); // need to append /r/n to fileStr ?

		// check the hash against CYMRU's registry using their whois API
		// To do this, we'll run whois on the commandline
		Runtime rt = Runtime.getRuntime();
		String[] commands = { "whois", "-h", "hash.cymru.com", md5Hash };
		Process process = rt.exec(commands, null);

		// Read the commandline output (CYMRU's response)
		BufferedReader stdInput = new BufferedReader(new InputStreamReader(
				process.getInputStream()));
		String cymruResponse = stdInput.readLine();

		// if string is malware, cymruResponse is in format of <hash> <time> <%>
		// if not malware, response is in format of <hash> NO_DATA
		if (cymruResponse == null)
			throw new IOException("couldn't reach cymru");
		if (cymruResponse.indexOf("NO_DATA") == -1)
			return true; // it's malware
		else
			return false;
	}

	/**
	 * Calculates and returns the MD5 checksum hash of a byte array.
	 * 
	 */
	static String getMD5(byte[] bytes) {

		MessageDigest md = null;
		try {
			md = MessageDigest.getInstance("MD5");
		} catch (NoSuchAlgorithmException e) {
		}
		byte[] digest = md.digest(bytes);
		return DatatypeConverter.printHexBinary(digest);
	}

	/**
	 * Creates and returns an http response containing an html page with a
	 * warning
	 */
	static String createMalwareWarningResponse() {
		return "HTTP/1.0 200 OK\r\n"
				+ "\r\n<!DOCTYPE HTML>\n<html>\n<body>\n<h1>UH OH.</h1>\n<br><h3>The address you requested "
				+ "was blocked because it is known to contain harmful malware. </h3>\n</body>\n</html>/r/n";
	}

	/**
	 * Sends client an http response with an html page saying there was an error
	 * connecting to the cymru malware registry. Closes connection with client.
	 * 
	 * @param socket
	 */
	static void sendCymruErrorMsg(Socket socket) {
		try {
			DataOutputStream outToClient = new

			DataOutputStream(socket.getOutputStream());

			outToClient
					.writeBytes("HTTP/1.0 200 OK\r\n"
							+ "\r\n<!DOCTYPE HTML><html><body><h1>There was an error connecting "
							+ "to the CYMRU malware hash registry. Please try again.</h1></body></html>/r/n");
			socket.close();
			return;
		} catch (Exception e) {
		}
	}

	/**
	 * If a client request has an invalid format, this method returns an HTTP
	 * response saying "Bad Request". Closes the socket after sending.
	 * 
	 * @param socket
	 */
	static void send400Error(Socket socket) {
		try {
			DataOutputStream outToClient = new DataOutputStream(
					socket.getOutputStream());

			outToClient
					.writeBytes("HTTP/1.0 400 Bad Request\r\n\r\n"
							+ "<!DOCTYPE HTML>\n<html>\n<body>\n<h1>There was an error with your request. "
							+ "Please try again.</h1>\n</body>\n</html>/r/n");
			outToClient.flush();
			socket.close();
			return;
		} catch (Exception e) {
		}
	}

	/**
	 * If client request includes a valid method other than "GET", returns an
	 * HTTP response saying "Not Implemented". Closes the socket after sending.
	 * 
	 */
	static void send501Error(Socket socket) {

		try {
			DataOutputStream outToClient = new DataOutputStream(
					socket.getOutputStream());

			outToClient.writeBytes("HTTP/1.0 501 Not Implemented\r\n\r\n" + 
			"<!DOCTYPE HTML>\n<html>\n<body>\n<h1>Only GET requests are accepted.\n. "
					+ "Please try again.</h1>\n</body>\n</html>/r/n");
			outToClient.flush();
			socket.close();
			return;
		} catch (Exception e) {
		}

	}

}
